Plugin guidelines
-----------------

This document is a companion to pluginspec.txt providing additional information
that isn't strictly required to develop plugins, but could reduce the amount of
your hair that it is necessary to tear out and/or make your plugin fit more
seamlessly into Miranda.

It's also an interesting list of some of the sparsely (if at all) documented
patches of the Windows API.

================================= User ====================================

* Font in dialog boxes

Miranda uses "MS Shell Dlg" size 8 in its dialog boxes. This is a pseudo-font
that maps to MS Sans Serif on Win9x/NT4 and Tahoma on WinME/2k/XP. Don't
hard-code Tahoma as the font because it wasn't shipped with Win9x/NT4 (although
it is shipped with MS Office).

* Dialog page sizes

The largest possible page in the options dialog is 314x240 DLUs (dialog box
units). The largest possible page in the view user details dialog is 222x132
DLUs.

* Options dialog tree

It was a design goal of Miranda's plugin interface that it should be possible
for plugins to have the same amount of power as the innards of Miranda. This
has mostly been accomplished, but it does lead to a further point: it is not
necessary for users to be aware of a distinction between Miranda parts and
plugin parts. What this is coming round to is the guideline that you should
first try to categorise your options page(s) in one of the existing major
groups (Contact list, events, network, status) before resorting to putting
it/them in the Plugins group if it doesn't fit anywhere else.

* HookEventMessage() with WM_USER in dialog boxes

DM_GETDEFID and DM_SETDEFID are defined to be WM_USER and WM_USER+1. So what?
Well, you know how events stop processing if one of the hooks returns nonzero?
These two messages will return nonzero if you return FALSE from a dialog box
procedure. What this means is that you should not use WM_USER or WM_USER+1 as
parameters to HookEventMessage() if your window handle is a dialog box because
either Windows will mess up Miranda, or Miranda will mess up Windows. I suggest
assigning WM_USERs to dialog boxes starting well away from here, say
WM_USER+10, because DM_REPOSITION was added in Win95 to, you guessed it,
WM_USER+2.

================================ Kernel ===================================

* Thread safety

You can ignore this section if your plugin doesn't create any additional
threads. It has turned out that the canonical source for information on thread
safety is miranda32/core/m_system.h under MS_SYSTEM_WAITONHANDLE. If this
document and that header disagree, that header is correct.

The most important point when using multiple threads is that CallService() will
not switch threads, it just calls the function, whereas NotifyEventHooks() will
switch to the main UI thread before calling the requested hooks. This has a few
implications: when calling CallService() from worker threads you need to check
that the service you're calling is thread-safe. All the database is, as is all
of protocols/protocols/ and, naturally, all of the modules functions. Also
ms_langpack_translate (and the Translate() macro wrapper) are safe. Some other
things may be safe, but I haven't properly investigated because these are the
really useful ones.

Also of note is that ms_proto_chainrecv does the same to-UI-thread translation
as notifyeventhooks() before calling each item to chain.

* The GetMessage() loop in core/miranda.c

The message pump is heavily altered from what you might expect a basic one to
look like. It has two main alterations. Firstly, it will call IsDialogMessage()
when it thinks it is necessary for it to do so. This makes tab, enter, escape
and all that lot work in modeless dialogs (created by CreateDialog() and
friends). Secondly, it waits using MsgWaitForMultipleObjectsEx() (or an
equivalent hack for win95 which doesn't have this function). This call waits
for window messages, the handles set by ms_system_waitonhandle and IO
completion alerts/asynchronous procedure calls (APCs).

Alertable waits are really badly documented considering how useful they can be.
They basically mean that you can call QueueUserAPC() with a handle to the main
thread and get your callback called when the main thread is next idle and
waiting. If you intend to use this, remember that GetCurrentHandle() returns a
pseudo-handle identifying the current thread, and must be DuplicateHandle()d in
order to get a real handle to the main thread that can be used from another
thread.

* Modal dialog boxes

That discussion wasn't just random background, it was going somewhere. Because
of this extra goodness, APIs that create their own message loop are evil
because they stop all this working. Noteably, all database writes from other
threads will halt until the APC queued by NotifyEventHooks() can be processed.
This means (among other more minor things) if you create your own message loop
no users will change status and no events can be received until the main loop
is back in control.

A (non-exhaustive) list of APIs that create their own loop is: MessageBox*(),
DialogBox*(), TrackPopupMenu*(), all the common dialog boxes.

Normally it's fine to have one of these functions around for only a short time
(ie the user ought to deal with them before they can continue using Miranda),
but if you're intending that they should have a long existence you need to
think about alternate solutions. Instead of MessageBox*() and DialogBox*() you
should use CreateDialog*(). Menus aren't normally much of a problem because
they go away fast but if you're really having issues then SetMenuInfo() is
available on 98+/2k+ and can create modeless menus.

The common dialog boxes are more of a problem. In Miranda I've mostly just
hoped I can get away with it and that the user won't leave them open forever.
The exception is the open file in the send file dialog which did get noticed.
The workaround I used was to create a new thread just to own the dialog, and
report back to the main thread when it had been closed. If you think you may
need a solution like this, the code's in sendrecv/file/filesenddlg.c.

There is one other time during which creating your own message loop is a bad
thing: during your plugin's Load() or me_system_modulesloaded hook. If you do
this it can cause bits of Miranda to load in a different order from that which
I intended, which tends to have unpredictable results.

* Rebase your plugins

All DLLs have a preferred load address. This is hard-coded into the file and is
the address at which all the jumps and pointers and stuff assume that the DLLs
has been loaded at. If the DLL can't be loaded at this address because another
DLL is already there, LoadLibrary() must run through the whole file changing
all the addresses. This has two detrimental effects: firstly it takes time and
secondly the DLL must be loaded into memory in order to do this. If the
addresses don't need to be changed then the code can simply be memory-mapped
from the file on the disk instead, which saves memory.

The default load address assigned by most C compilers is 0x10000000, which
means there are a large number of DLLs all trying to load at the same place and
all but one of which need to be moved.

If you need a visual example, there's an option in Process Explorer from
www.sysinternals.com that can highlight all DLLs that have needed to be moved
in a sickly yellow colour. I don't actually have information on how many
Miranda plugins haven't been rebased, but I do know that Winamp's default
plugins as shipped are quite bad offenders.

To rebase your plugin, either change the 'Base address' in the 'Output'
category of the 'Link' page of the project settings dialog in MSVC, or run the
REBASE tool on your DLL once it has been created. Suggested addresses are
anywhere between 0x10000000 and 0x50000000. Below this you start to interfere
with DLLs rebased at load time, above this you interfere with Windows DLLs
(uxtheme.dll at 0x5b0f0000 is the lowest I've seen to date). Setting the first
three digits will allow plenty of space between plugins. If you are a concerned
user reading this (or you want to fix Winamp :-) ), REBASE doesn't need source
code or anything. Just run the following command in your plugins directory:
REBASE -b 0x20000000 *.dll

If you're still confused, there's quite a lot of information on this subject in
Tech Articles, Periodicals and Backgrounders in the MSDN. "rebase" is a good
search term.

* DisableThreadLibraryCalls()

Look it up. If you don't need the DLL_THREAD_ATTACH and DLL_THREAD_DETACH
notifications to your DllMain() then there's a little optimisation to be had
here.

* Don't use GetModuleHandle(NULL)

Miranda is full of this function call because at some point I considered it
neater than having a global HINSTANCE variable. Almost certainly not the case,
but I'm not going to change it now. Anyway, this call returns an HINSTANCE to
the current executable, *not* the current module, so if you try to copy code
from Miranda that loads resources you must replace it with the HINSTANCE you
got from DllMain() or your plugin will try to load its resources from
miranda32.exe.

* Using Dr Watson crash dumps

This is somewhat of a black art because it requires a large amount of quite
disparate knowledge, including a healthy smattering of assembler. I haven't
been able to find any really good web pages on how to do it well. In fact, the
only page I've found that gets anywhere close is
http://www.candle.com/www1/cnd/portal/CNDportal_Article_Master/0,2245,2683_2947_46042,00.html
but that doesn't mention any of the things that can (and often do) go wrong.

================================ Miranda ==================================

* Module naming

The database, netlib, protocols, and a few other things all require a module
name. This really needs to be unique, and there haven't been any problems with
overlaps so far, in the same way that there haven't been two plugins with the
same filename yet. This section exists, therefore, just to remind you to use a
little intelligence when choosing a suitable name. "MyPlugin" is clearly a
silly name to use.

* Scope of features

The MIRANDAPLUGININFO structure has only one field for overriding built-in
modules. I thought long and hard about this when I was designing the structure
and decided that by enforcing that only one built-in module can be replaced, it
encouraged another desirable goal: plugins shouldn't try to do too much. To
pick a wild example, don't write a plugin that both checks your mail and
provides a UI for send/recv contacts. Clearly there will be people that want
one feature but not the other and very little is gained in either load time or
memory usage by packing them into one DLL. Don't do it.

* Database considered untrusted

Miranda is a network app, hence needs to be carefully written lest it be
subject to all those exploits you keep reading about for IE and IIS. In most
cases it is obvious when data has come over the network and should be treated
with great care. What isn't so obvious is that a lot of the information in the
database (both events and settings) has been through very little sanity
checking prior to getting there. For this reason, the contents of the database
should be considered just as untrusted as if it had had no prior processing. If
you're not sure what to trust and what not to, trust noone. Don't assume that
anything has the correct \0 terminators and use the 'n' versions of string
functions (strncat, strncpy (or lstrcpyn which puts the terminator on),
_snprintf, etc, etc).

* Confusing return values from services and hooks

There are two schools of thought as to return values: return nonzero on success
and put error codes elsewhere (_errno or GetLastError()), or return the error
code itself and zero on success (eg the Windows registry functions). I elected
to go with the latter for the majority of Miranda because it's smaller,
although it makes more sense to computers than to people. If this confuses you
then you can use macros to make it clearer that if(!DBGetContactSetting(...))
is testing for success, for instance:
if(DBGetContactSetting(...)==ERROR_SUCCESS) or
if(DBGetContactSetting(...)==NO_ERROR).

Don't use if(SUCCEEDED(DBGetContactSetting(...))) because the SUCCEEDED() macro
from winerror.h doesn't do the correct test, but you can make your own macro if
you feel like it:
#define OK(result)  ((result)==0)

The most important point to go away from this section with is that you must
return zero from hooks in order to continue processing. There have been a
number of problems associated with plugins not obeying this, some of which have
only shown up much later.

* Unhook everything

In the Unload() of your plugin you must UnhookEvent() all events that you have
HookEvent()ed or HookEventMessage()d, particular database hooks and
me_proto_ack. This is because plugins are not unloaded from memory as the last
thing in Miranda's shutdown procedure, other parts of Miranda will continue to
close after the plugins *and may write settings to the database in doing so*.
If your plugin has left an open hook, when it is called it will be pointing
into the blank space where your plugin used to be: instant gpf.

* Contact status changes

No gotchas here, but it's not very obvious how you get notified of this. You
can either use a ME_DB_CONTACT_SETTINGCHANGED hook and test the module from
MS_PROTO_GETCONTACTBASEPROTO and WORD setting "Status" or (a bit faster) use
ME_CLIST_CONTACTICONCHANGED. There's no standard way to get the status from
which a contact has changed.

* Acks from message sending

This section is only of interest to people writing network protocol plugins. If
the IM network you are writing for doesn't allow for message acking (ie once
you send the message it is assumed to have been sent correctly), you cannot
call ProtoBroadcastAck() before your PSS_* has returned for the obvious reason
that the caller needs to know the hProcess that it's waiting for before the ack
actually arrives. There are two solutions to this, both of which rely on the
fact that once control has returned to the main message loop you know that your
function must have returned. Firstly, you can use SetTimer() with a short
timeout. Even when SetTimer() is using a callback function it still posts
WM_TIMER to the message loop and only calls the function when that is received.
Secondly, NotifyEventHooks() goes through the message loop when it is called
from a secondary thread (as described in 'The GetMessage() loop', above). You
can exploit this by starting a thread and calling ProtoBroadcastAck() from
there.

* MS_PROTO_GETCONTACTBASEPROTO can return NULL

It doesn't happen often, so some plugins get caught out by it (and generally
crash), but if you have contacts in the list that are owned by a protocol
plugin that is no longer loaded then calling ms_proto_getcontactbaseproto on
them will return NULL. Typical places for this to occur are at load time and
when right-clicking a contact (in me_clist_prebuildcontactmenu). You should
verify that all your calls to ms_proto_getcontactbaseproto check for a NULL
return value.

* plugin-dev

And one last bonus item. I'll always do my utmost to answer any questions that
turn up on the plugin-dev forum. As long as they've got vaguely something to do
with Miranda and/or ICQ it doesn't matter if they don't contain any Miranda-
specific code. I know that there's a very solitary aspect of programming that
causes people to struggle on their own before seeking help (and I've been just
as guilty as anybody else of this in my time), but trust me on this one: I know
more about Miranda than you do. Hell, if you're too embarrassed about looking
stupid then e-mail me and I can tell you privately how stupid you look.
