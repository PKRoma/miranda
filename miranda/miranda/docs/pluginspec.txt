Guide to writing plugins
~~~~~~~~~~~~~~~~~~~~~~~~

Read this in conjunction with:

miranda32/random/plugins/newpluginapi.h
miranda32/core/modules.h
docs/modularity drafts.txt
and all the m_*.h that are around

plugins/testplug/main.c is the best sample code around as of writing.


Functions exported by your plugin
---------------------------------

extern "C" PLUGININFO* __declspec(dllexport) MirandaPluginInfo(DWORD mirandaVersion)

Called by Miranda as soon as it finds your plugin. Must return a statically
allocated PLUGININFO structure (ie just define it globally in your plugin and
return a pointer)

from newpluginapi.h:
typedef struct {
	int cbSize;
	char *shortName;
	DWORD version;
	char *description;
	char *author;
	char *authorEmail;
	char *copyright;
	char *homepage;
	BYTE isTransient;
	int replacesDefaultModule;
} PLUGININFO;

cbSize is the size in bytes of the structure. shortName is what will be shown
to the user most of the time, so don't make it the same as the filename.
version is created by the PLUGIN_MAKE_VERSION(a,b,c,d) macro.
description, author, authorEmail, copyright and homepage are all self-
explanatory.

isTransient is not implemented yet, but once it is, if it is nonzero it will
cause your plugin to be removed from memory as soon as Load() has been called,
only to be reloaded again when a service created with
CreateTransientServiceFunction() is called.

replacesDefaultModule specifies if this plugin replaces any of the
functionality which is built in to Miranda. splitmsgdialogs is a very good
example of this, in that it replaces the built in message send/recv user
interface entirely. Miranda needs to know this so it can disable the built in
feature to stop the two interfering. Miranda will also notify the user if they
try to install two plugins that implement the same feature and offer to disable
one or both of them. If you do replace a built in feature, you should make
yourself fairly familiar with what you are replacing so plugins and parts of
Miranda that are expecting the original feature do not break. It should be zero
if you're not replacing anything, or one of the DEFMOD_ constants in
m_plugins.h if you are.

Note: The functions can potentially be called in the following orders:
1) DLL load, MirandaPluginInfo(), Load(), zero or more calls of
   MirandaPluginInfo(), Unload(), DLL unload
2) DLL load, MirandaPluginInfo(), DLL unload
Plugins should be able to cope with both these behaviours.

If you return NULL from this function Miranda will assume that the plugin is
incompatible with this version and continue no further.

----

extern "C" int __declspec(dllexport) Load(PLUGINLINK *link)

Called when your plugin is known to be enabled and compatible. You should save
the link pointer globally so that the functions within it can be accessed for
the rest of your runtime. It is strongly recommended that it is put in a global
variable PLUGINLINK *pluginLink since there are #definitions in newpluginapi.h
that allow you to use the function names without prefixing them with
pluginLink-> all the time.

You should return zero from this function if loading was successful.

----

extern "C" int __declspec(dllexport) Unload(void)

Called during Miranda's cleanup sequence. Specifically, within the
Miranda/System/Shutdown event from core/m_system.h


So how do I do stuff then?
--------------------------

Read docs/modularity drafts.txt for information on the design and the why of
this setup, but I happen to be quite pleased with it, so don't knock it.

Read core/modules.h for documentation on the 10 functions in PLUGINLINK.

Back? Good. Now you know that there exist services and hooks, so I'll give a
quick run through of how they're used.

----

Services

Services are just function calls hidden behind a layer. An example:

SetDlgItemText(hwndDlg,IDC_CONTACTNAME,(char*)CallService(MS_CLIST_GETCONTACTDISPLAYNAME,(WPARAM)hContact,0));

Go and look up the SetDlgItemText() function in Microsoft's documentation if
you aren't familiar with it, it's the CallService() we're interested in. There
are 4 things you want to know now:

What's MS_CLIST_GETCONTACTDISPLAYNAME? It's #defined in
ui/contactlist/m_clist.h to be a string (you don't need to know what string).
CallService() will look up this string in it's table to find the actual
function pointer and then call that for you. This particular function gets
the name Miranda will use on the contact list to represent a contact.

How did I know it existed? The difficult one. You didn't, because you didn't
write it. Actually, though, there are only 3 header files that you need to know
all about. database/m_database.h is the best to start with, since a lot of
Miranda hinges about it and there's some good background information in there.
ui/contactlist/m_clist.h has some useful routines in, as does
random/skin/m_skin.h. All the others are pretty obvious what's in them
(ui/options/m_options.h, for instance), although protocols/icq/m_icq.h deserves
honorable mention because this is, after all, an ICQ programme.

Where did the parameters come from? Every service function is documented in its
associated header file, to a greater or lesser extent, depending on how I was
feeling when I wrote it.

Wow! How do I make my own service function? With CreateServiceFunction(). Look
it up in core/modules.h.

It's also worth noting that CallService() will return CALLSERVICE_NOTFOUND if
it didn't find the service you asked for.

----

Events

Events are sent when you wish to declare that something has happened to anyone
who might be interested. You declare your interest in an event using
HookEvent() or HookEventMessage() (see modules.h) with the name of the event
and how you want to receive the notification.

Event names are also listed in the header files for modules. There are some
particularly interesting ones in database/m_database.h.

You can make your own event with a call to CreateHookableEvent(), saving the
handle returned which you later use in a call to NotifyEventHooks().

----

Final Words

Yes, you do need to get all those header files from the source.

I've tried to make all the services extensible while maintaining backward
compatibility.

There is potential for forward referencing problems with service and hook
names. For example, you may wish to hook ME_ICQ_LOG, but you can't do it in
the Load() from your plugin because the plugins all get loaded before the ICQ
module has been loaded. Look up ME_SYSTEM_MODULESLOADED in core/m_system.h
for the resolution to this problem.

The Load() function from plugins/splitmsgdialogs/main.c is a very standard
example of the sort of things you need to do. It:

Hooks ME_DB_EVENT_ADDED so it knows when a message arrives.
Creates a couple of service functions with unimportant names because the
  contact list menu functions require the name of a service.
Adds a menu item to the context menus of contacts on the list.
Sets itself to be called when a contact is double-clicked
Registers a new sound to appear in the sound options dialog.


FAQs
----

How should I save my settings?

With the MS_DB_CONTACT_WRITESETTING and MS_DB_CONTACT_GETSETTING services
from database/m_database.h. Store settings that apply to a specific
contact in that contact, and everything else under the contact NULL.
szModule should be some sort of unique name for your plugin. Make it a
CLSID if you want to guarantee uniqueness, but the filename's probably a
more readable option. Don't forget to free any strings you read with
getsetting by using MS_DB_CONTACT_FREEVARIANT.

What about translation?

Translation services are provided by random/langpack/m_langpack.h, which you
should use to make sure your plugin is localisable. It's not a big hassle to
use, but you do need to be aware that translation services are unavailable in
0.1.0.1 and below.

More FAQs and general other stuff are in pluginguidelines.txt
