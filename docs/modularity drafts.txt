These are notes from various e-mails Richard wrote to explain the new
modularity. They may be outdated but they provide still-relevant insights into
why various design decisions were made

See core/modules.h for the current best and most accurate documentation

--------------------------- First draft of thoughts, no code written thus far

Random modular arrangement

The key ethos of my system of modularisation is making evident the
communication paths between components. I propose a system based on two
key elements: the service function and the hook. A service function is
the same as an exported function but more rigidly controlled to prevent
random importing of useful but internal functions. A hook is much the
same as a Windows callback for notification of various events. They
would be declared as:

typedef int (*MIRANDASERVICE)(WPARAM,LPARAM);
typedef int (*MIRANDAHOOK)(WPARAM,LPARAM);

lParam should never be used for anything except a structure or 0 to
allow clean extensibility. A service's parameters and return value are
defined by the creator. A hook's parameters are defined by the event's
creator, its return value should be true to continue calling the rest of
the hooks in the chain or false to stop (for really terminal errors
only). Services should *never* return -2^31, 0x80000000, since that
value is reserved for 'the service name was not found'.

Hooks and services would be named using strings, using a form such as
"Module/Component/HookOrService", for example
"Miranda/ContactList/AddContact". Although hooks and services will be
stored in separate lists, name overlap should be avoided.

Eight functions will be needed to manage this:

//hook functions
HANDLE CreateHookableEvent(const char *name);
int DestroyHookableEvent(HANDLE hEvent);
int NotifyEventHooks(HANDLE hEvent,WPARAM wParam,LPARAM lParam);
HANDLE HookEvent(const char *name,MIRANDAHOOK hookProc);
int UnhookEvent(HANDLE hHook);
//service functions
HANDLE CreateServiceFunction(const char *name,MIRANDASERVICE
serviceProc);
int DestroyServiceFunction(HANDLE hService);
int CallService(const char *name,WPARAM wParam,LPARAM lParam);

Pros:
- Enforced modularity
- Those eight functions are exactly the same ones as need to be sent to
plugins, thus completely blurring the distinction between plugins and
built-in modules.
- All the usual pros for modularity, ie clarity, interoperability,
algorithm hiding, etc.
- Such cleverness as being able to have two (or more) completely
interchangeable 'contact list' modules. One being a small-footprint
version, and another with support for ICQPlus skins and loads of pretty
doodads.
- Each person can own their own module without concern for what other
people are doing. They just need to make sure that the right services
and hookable events exist. It doesn't matter if two modules are
developed independently because when put together they should still work
with the new versions of the other.
- It becomes very difficult to avoid writing helpful and relevant
documentation in the header files for each module.

Cons:
- The big one is that the whole tree needs to go offline for a few days
while one person rearranges the entire thing.
- I realise the inefficiencies of using strings for naming, but believe
that the advantages of modularity outweigh the negligible speed loss if
a good hashing scheme is used.
- Some sort of mechanism needs to be devised for getting all the modules
to load in the right order. Clearly the database must be loaded before
the contact list, etc.
- Some of the compiler's type checking is lost, but with clear naming
this shouldn't be too much of a problem.
- There is potential for sloppiness in creating services and hookable
events. For example, the database module will almost certainly have a
function called FindDatabasePath() or somesuch, but this should not be
visible globally since it could give modules the idea that they could
parse the database themselves, when it is not difficult to make it such
that only the database module need know any information about its file
format.

--------------------- Some random questions and answers arising from the above

> Does each module have the ability to acess each other module? is it
> done via the core?

The huge bonus of modularity is that all inter-module access is
carefully regulated. There are two possible communication paths - one
pro-active the other reactive.

The pro-active one is service functions: a module declares to the core
that it is offering a service with a specific name using
CreateServiceFunction with the name and a pointer to the function. This
function is then available for all modules to call by using its name and
the desired parameters in a call to CallService

On the reactive side are hookable events: a module declares that it will
notify anyone who's interested when a specific named event happens using
CreateHookableEvent which returns a handle to the new event. That module
can then call NotifyEventHooks using that handle to signal whatever it
was signalling. A different (or the same) module can add itself to an
event chain so as to be called whenever an event is triggered using
HookEvent with the name of the event and a pointer to its own function
to be called.

> how does the IM modules know which module is the GUI (ie to handle
> changing user status on the screen)?

This is clearly a special case of a much more general question, but I
hope by answering the special case I will answer the general question
too.

The basic answer is that it knows because the GUI header file contains a
listing of the names of all the services and events it provides as
#defines.

How this works in practice is a tad complicated since we must support
multiple protocol libraries (icq and msn currently). I envisage that
when the user selects a different status mode the UI triggers a 'user
status changed' event with parameters containing the new state. The
protocol modules will have hooked this and will send what they need to
send to their servers and when the server has confirmed the state change
they will call a UI service notifying it of the change. This arrangement
also allows for when the ICQ server suddenly drops the user: the icq
module will simply call the UI service and tell it so, just as if the
user had initiated the action. For modules such as auto-away, the UI
will have another service function to allow any module to change the
status mode without user interaction.

As you can see, figuring out this sort of thing requires a little work,
but the result is that every inter-module interaction is clearly and
precisely defined, with no subtle side-effects as is all to easy with a
large monolithic programme. Nobody need know any details of how a
particular module works, they just need to know what events it provides
that they can hook, and what services they can call.

> What effect is this going to have on speed and probably more
> importantly, memory usage. If each component is in a dll of its own
> then there is sure to be some overhead to for each dll loaded.

I can't see why you'd be so concerned about bloat...after all, what
other ICQ client is such a memory hog? :-)

Joking aside, memory usage is a good reason for going modular. The thing
you misunderstood was that every module *can* be in its own DLL, but
need not be. In fact, a module can be flipped between in-exe and as a
dll with very very little effort. In the initial conversion I think I
would put just about everything in the exe, except maybe a few really
rare things like the 'check for updates' and 'import icq database', and
maybe 'find/add users'. The removal of these things would have just
about no impact on speed since they're so rarely used, but it would
reduce the exe size a bit. You are right to be concerned about DLLs,
though - they certainly do have a fairly hefty overhead and also take a
while to load.

As for the infrastructure, it's difficult to say if there would be any
difference in size or not, or even whether it would be bigger or
smaller. There are just too many factors involved.

Thinking about speed, all the add/create stuff functions can be ignored
since they're only called a few times. NotifyEventHooks is blindingly
fast because it uses a handle straight into a list of functions and just
calls each in turn. CallService is more of a problem (and sadly probably
more commonly used) since it has to interpret a string. I think,
however, that with a good hashing algorithm the speed will be more than
adequate. You'll just have to trust me on that one.

----------------------- My comments on the existance of sync code

> I noticed there is a lot of syncronisation stuff (MUTEXes etc) in
> there. Do you All the components have to be thread safe? Does each
> component run it a seperate thread?

No, I just like to hedge my bets. It would be Very Bad if the database
got corrupted just because another thread got created, just as it would
be Bad if the core module manager fell apart. Besides, multithreading's
fun! :-)

I haven't created any extra threads yet, mainly because icqlib doesn't
look very thread-safe to me, although I haven't spent a lot of time
looking at it. Threads are good, however, and should be able to do a lot
to reduce the amount of random CPU usage while checking the network so
I'll look into it more when I've finished restructuring.

As for the thread-safe situation, all modules except the database and
the module manager (not a module but never mind) should be considered
thread-unsafe and any callers using multithreading should synchronise
all their cross-module accesses to the main thread.

My modularity is really just a fancy way of hiding lots of plain
function calls.
