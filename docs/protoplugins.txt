Protocol plugins
~~~~~~~~~~~~~~~~

This is a document on what you need to do to write a protocol plugin. You
should already be very familiar with writing standard plugins before you
tackle this. You should read this in conjunction with
miranda32/protocols/protocols/m_*.h

As well as connecting to different servers, the information here can be used
to layer routines on top of existing protocols, such as encryption and
on-the-fly translation, amongst others.

-----
Identification

Your module will need a unique name. Do not use a generic name such as "AIM" or
"MyMSN" since it could lead to overlap, rather pick something that looks as
though it should be unique. Your Sourceforge login is a good source of
uniqueness.

In your plugin's Load() function you need to register this name with the
protocol manager by calling MS_PROTO_REGISTERMODULE. In this way the protocol
manager has a complete list of all active protocol modules.

Each contact also has its own ordered list of protocols that is used whenever
network access is needed. The actual network transport is at the end of the
list, and before that is anybody else who is interested. The order is
determined by the module type passed to registermodule. Lower numbers go at
the end of the list.

-----
Communication

When a protocol function for a specific contact is called, each protocol in the
list for that contact is tried, in order, and the first module which contains
the specific function is called. Each function until it reaches the Internet
should chain the next module in sequence using MS_PROTO_CHAINSEND.

When an event is received from the network, the protocol module should pass the
data down the correct contact's function chain in reverse order before doing
the normal processing for the event. MS_PROTO_CHAINRECV is used for this.
CHAINRECV calls the protocol chain in reverse order, but calls the original
module at the end as well, so that information on the stack of the calling
functions will still be valid.

If a service does not want to chain the operation, it should return a nonzero
value to indicate failure. Further processing for the operation will cease.

-----
Services

You should implement as many of the protocol services from m_protosvc.h as are
relevant. You are free to expose other services, however they will only be
supported by modules that specifically know of their existence.

-----
Database settings

There are a number of standard setting names that should be used to supply the
relevant information whenever it is made available by a network-access protocol
module:

Network information:
"IP" (dword)
"Port" (word)
"Status" (word) using values from ui/contactlist/statusmodes.h
"Auth" (byte) true if the contact requires an authorisation step before they
              can be added
"ApparentMode" (word) the visible/invisible status of the contact, 0 if no
              status. Takes values from statusmodes.h otherwise. Only valid if
	      the protocol supports such settings.
"IdleTS" (dword) time that the user went idle (0 if not idle)

Personal details:
"Nick", "FirstName", "LastName", "e-mail", "City", "Country", "State", "Phone",
"Homepage", "About" (string)
"Age" (word, 0=unspecified)
"Gender" (byte: 'M', 'F' or '?')

This list may be added to when it becomes useful to do so.

-----
Database events

If modules create database events with the predefined EVENTTYPE_ constants from
m_database.h then they should use the same formats as used by the icqlib module
for the contents. The szModule structure entry should be set to your module's
name, however.